package io.grapevine.core.identity

import io.grapevine.core.crypto.CryptoProvider
import org.slf4j.LoggerFactory
import java.util.concurrent.locks.ReentrantReadWriteLock
import kotlin.concurrent.read
import kotlin.concurrent.write

/**
 * Manages user identity creation, storage, and retrieval.
 *
 * On first launch, automatically generates a new Ed25519 key pair
 * and stores the private key securely using the OS secure storage.
 *
 * This class is thread-safe.
 */
class IdentityManager(
    private val secureStorage: SecureStorage,
    private val cryptoProvider: CryptoProvider = CryptoProvider(),
    private val identityBackup: IdentityBackup = IdentityBackup()
) {
    private val logger = LoggerFactory.getLogger(IdentityManager::class.java)
    private val lock = ReentrantReadWriteLock()

    @Volatile private var cachedPrivateKey: ByteArray? = null
    @Volatile private var cachedIdentity: Identity? = null

    /**
     * Initializes the identity manager.
     * If no identity exists, generates a new key pair.
     *
     * @return The current identity
     */
    fun initialize(): Identity = lock.write {
        logger.info("Initializing identity manager")

        return@write if (hasIdentityInternal()) {
            logger.info("Loading existing identity")
            loadIdentityInternal()
        } else {
            logger.info("No existing identity found, generating new key pair")
            generateNewIdentityInternal()
        }
    }

    /**
     * Checks if an identity already exists in secure storage.
     */
    fun hasIdentity(): Boolean = lock.read {
        hasIdentityInternal()
    }

    private fun hasIdentityInternal(): Boolean {
        return secureStorage.exists(SecureStorage.PRIVATE_KEY_ID)
    }

    /**
     * Gets the current identity, initializing if necessary.
     */
    fun getIdentity(): Identity {
        // Fast path: check volatile field first
        cachedIdentity?.let { return it }
        return initialize()
    }

    /**
     * Gets the private key bytes for signing operations.
     * Returns null if no identity exists.
     */
    fun getPrivateKey(): ByteArray? = lock.read {
        cachedPrivateKey ?: run {
            val key = secureStorage.retrieve(SecureStorage.PRIVATE_KEY_ID)
            if (key != null) {
                lock.write { cachedPrivateKey = key }
            }
            key
        }
    }

    /**
     * Gets the public key bytes.
     */
    fun getPublicKey(): ByteArray {
        return getIdentity().publicKey
    }

    /**
     * Generates a new identity with a fresh Ed25519 key pair.
     * This will overwrite any existing identity.
     *
     * @return The newly created identity
     */
    fun generateNewIdentity(): Identity = lock.write {
        generateNewIdentityInternal()
    }

    private fun generateNewIdentityInternal(): Identity {
        logger.info("Generating new Ed25519 key pair")

        val keyPair = cryptoProvider.generateSigningKeyPair()
        val privateKey = keyPair.secretKey.asBytes
        val publicKey = keyPair.publicKey.asBytes

        // Store private key securely
        val stored = secureStorage.store(SecureStorage.PRIVATE_KEY_ID, privateKey)
        if (!stored) {
            throw IdentityException("Failed to store private key in secure storage")
        }

        // Create and cache identity
        val identity = Identity(
            publicKey = publicKey,
            createdAt = System.currentTimeMillis()
        )

        cachedPrivateKey = privateKey
        cachedIdentity = identity

        logger.info("New identity created with short ID: ${identity.shortId}")
        return identity
    }

    /**
     * Loads an existing identity from secure storage.
     *
     * @return The loaded identity
     * @throws IdentityException if the identity cannot be loaded
     */
    fun loadIdentity(): Identity = lock.write {
        loadIdentityInternal()
    }

    private fun loadIdentityInternal(): Identity {
        val privateKey = secureStorage.retrieve(SecureStorage.PRIVATE_KEY_ID)
            ?: throw IdentityException("No identity found in secure storage")

        // Derive public key from private key
        // Ed25519 private keys (as generated by libsodium) are 64 bytes:
        // first 32 bytes are the seed, last 32 bytes are the public key
        val publicKey = if (privateKey.size == ED25519_SECRET_KEY_SIZE) {
            privateKey.copyOfRange(ED25519_SECRET_KEY_SIZE - Identity.PUBLIC_KEY_SIZE, ED25519_SECRET_KEY_SIZE)
        } else {
            throw IdentityException("Invalid private key format: expected $ED25519_SECRET_KEY_SIZE bytes, got ${privateKey.size}")
        }

        val identity = Identity(
            publicKey = publicKey,
            createdAt = System.currentTimeMillis() // We don't persist createdAt yet
        )

        cachedPrivateKey = privateKey
        cachedIdentity = identity

        logger.info("Identity loaded with short ID: ${identity.shortId}")
        return identity
    }

    /**
     * Clears the cached identity and private key.
     * Does not delete from secure storage.
     */
    fun clearCache() = lock.write {
        cachedPrivateKey?.fill(0) // Securely clear the private key from memory
        cachedPrivateKey = null
        cachedIdentity = null
    }

    /**
     * Deletes the identity from secure storage.
     * This is a destructive operation and cannot be undone.
     *
     * @return true if deletion was successful
     */
    fun deleteIdentity(): Boolean = lock.write {
        logger.warn("Deleting identity from secure storage")
        clearCacheInternal()
        secureStorage.delete(SecureStorage.PRIVATE_KEY_ID)
    }

    private fun clearCacheInternal() {
        cachedPrivateKey?.fill(0)
        cachedPrivateKey = null
        cachedIdentity = null
    }

    /**
     * Exports the current identity to an encrypted backup file.
     *
     * @param password User-provided password for encryption
     * @param outputFile The file to write the backup to
     * @throws IdentityException if no identity exists
     * @throws IdentityBackupException if backup fails
     */
    fun exportBackup(password: String, outputFile: java.io.File) = lock.read {
        val privateKey = getPrivateKey()
            ?: throw IdentityException("No identity to export")
        val identity = getIdentity()

        logger.info("Exporting identity backup to ${outputFile.absolutePath}")
        identityBackup.exportBackup(privateKey, identity, password, outputFile)
    }

    /**
     * Imports an identity from an encrypted backup file.
     * This will replace the current identity.
     *
     * @param backupFile The backup file to import
     * @param password The password used to encrypt the backup
     * @return The restored identity
     * @throws IdentityBackupException if import fails
     */
    fun importBackup(backupFile: java.io.File, password: String): Identity = lock.write {
        logger.info("Importing identity backup from ${backupFile.absolutePath}")

        val backupData = identityBackup.importBackup(backupFile, password)

        // Store the private key
        val stored = secureStorage.store(SecureStorage.PRIVATE_KEY_ID, backupData.privateKey)
        if (!stored) {
            throw IdentityException("Failed to store imported private key in secure storage")
        }

        // Create and cache the identity
        val identity = backupData.toIdentity()
        cachedPrivateKey = backupData.privateKey
        cachedIdentity = identity

        logger.info("Identity imported successfully with short ID: ${identity.shortId}")
        identity
    }

    /**
     * Validates a backup file without importing it.
     *
     * @param backupFile The backup file to validate
     * @return true if the file appears to be a valid Grapevine backup
     */
    fun isValidBackupFile(backupFile: java.io.File): Boolean {
        return identityBackup.isValidBackupFile(backupFile)
    }

    companion object {
        /** Ed25519 secret key size (64 bytes: 32 bytes seed + 32 bytes public key) */
        private const val ED25519_SECRET_KEY_SIZE = 64
    }
}

/**
 * Exception thrown when identity operations fail.
 */
class IdentityException(message: String, cause: Throwable? = null) : Exception(message, cause)
